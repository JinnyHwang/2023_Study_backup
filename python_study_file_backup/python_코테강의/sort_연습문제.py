
'''
정렬 : 가장 큰 수

매 단계에서 비교해서 우선하는걸 고르는 것 : O(n^2)
정렬 알고리즘을 사용 : O(nlogn)

정렬에 사용되는 기준
1. 맨 앞자리 수가 큰 것
2. 다음 자리 수가 본인보다 큰 것
3. 본인과 동일하거나 없는 것
4. 다음 자리 수가 본인보다 작은 것
---> 이거 아님

크게 만드는 수 기준


3 32 33 34

3 vs 32
332 323 -> 3

3 vs 33
333 -> 아무거나

3 vs 34
334 343 -> 34


34 342 343 344

34 vs 343
34343 34334 -> 34
-> 기준은?

결과의 수를 가장 크게 만들 수 있는 수가 앞에 오도록 정렬 해야함\
!!!만약 정렬이 잘 되어있다 가정했을 때!!!
34로 만들 수 있는 가장 큰 수는?
34343434... 바로 자기 자신을 이어 붙힌 것
34 : 34343434...
vs
343 : 343343343...

문제에서 1000이하의 수라고 했으니
4자리수로 끊어서 비교한다면
34 vs 343 == 3434 vs 3433

---> 아이디어 진짜 천재 아니냐, 수학 천재...

대소 관계 비교 기준
-> 정렬이 잘 되어있다 가정했을 때,
현재 값에서 만들 수 있는 가장 큰 수는
그 값을 이어 붙힌것.
때문에 크기 비교 시 모든 값을
문제에서 주어지는 4자리 숫자로 이어붙였을 때 값으로 비교
-> 발상 정말 천재..


[구현]
1. 대소 관계 비교를 위한 기준 마련
2. 주어진 배열 정렬
3. 정렬된 배열 이용해서 문자열 표현 완성

(+) sort : 원본을 변형해서 정렬
sorted : 원본을 변형시키지 않음
sort, sorted 모두 key, reverse를 매개변수로 가짐
Ex1. reverse만 사용하는 경우 : sorted([3, 2, 6, 6], reverse=True) : 역순으로 리스트 정렬됨
Ex2. key만 활용 : sorted(['232', '643', '825'], key=lambda x : x[1] )
: lambda에서 정의한 key값을 기준으로 오름차순 정렬.
Ex3. ex_list.sort( key=lambda x : x*2, reverse=True)

(+) join 함수 : 문자열 합치기
'구분자'.join(리스트) : 원소 사이에 구분자를 넣어 문자열을 만들어줌

'''

'''
lambda 함수
lambda 인자 : 표현식

Ex1. (lambda x, y : x+y)(1, 2)
Ex2. map( lambda x : x**2, range(5) )
'''

# 0으로만 구성된 숫자는 : 0 만 출력되야함. 0000은 아님.
def solution(numbers):
    numbers = [ str(x) for x in numbers]
    numbers = list( map( str, numbers ) )
    
    # 숫자는 기본적으로 오름차순으로 정렬
    # 내림차순으로 정렬하기 위해 reverse 사용
    
    # 리스트 정렬
    # 가장 작은 수는 한자리. 4번은 돌려야 모든 수가 4자리수가 나옴
    # 맨 앞에서부터 3번 index까지 끊음
    # lambda 식으로 도출한 x를 기준으로 정렬
    # 큰 값이 앞에오도록 내림차순 정렬
    # 해당 코드에서 가장 큰 시간복잡도 가짐
    numbers.sort( key = lambda x : (x*4)[:4] , reverse=True )
    
    # 0으로만 구성된 숫자는 : 0 만 출력되야함. 0000은 아님. -> 문제를 꼼꼼하게 봐야함
    # 정렬했는데 맨 앞에 정렬된 문자열의 첫 번째 문자가 0이면
    if numbers[0] == '0':
        answer = '0' # 시간복잡도 상수에서 끝낼 수 있음
    else :    
        # number에 정렬된 모든 원소를 하나로 이어붙이기
        # 띄어쓰기 없이 한줄로 join을 사용해 문자열 이어붙이기
        answer = ''.join(numbers) # 시간복잡도는 numbers에 들어있는 원소수의 개수에 비례
    return answer
# 효율성 테스트 없이 정확도만 보고 만든 알고리즘
    

print((lambda x, y : x+y)(1, 2))
print( list(map( lambda x : x**2 , range(5) )) )




