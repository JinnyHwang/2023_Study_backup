
'''
동적계획법 Dynamic Programming
N으로 표현

주어진 최적화 문제를
재귀적인 방식으로 작은 부분 문제로 나우어서
부분 문제를 풀고, 이 해를 조합
전체 문제의 해답에 이르는 방식

알고리즘의 진행에 따라 탐색해야 할 범위를 동적으로 결정
탐색 범위를 한정할 수 있음
-> 모든 조합을 탐색하기에 비효율적일 경우 사용

피보나치수열 -> 재귀로 구현
=> 같은 인자로 재귀 함수를 여러번 호출해야하는 맹점이 있다.
복잡도: 지수 함수 형태

=> 동적계획법 적용하면?
부분 문제를 풀어내고, 해당 해를 다음 단계헤서 사용하는 것
복잡도: 선형함수의 형태

* Knapsack Problem : 알아보기

동적계획법으로 설계

N을 한 번 사용해서 만들 수 있는 수 -> ...
N을 두 번 사용해서 만들 수 있는 수 -> ...
N을 세 번 사용해서 만들 수 있는 수 -> ...
반복하다가 내가 만들고자 하는 수가 나타나면 끝

숫자를 사용하는 개수로 조합! (결과값은 집합으로 표현해야 중복 없앨 수 있음)

단계 1 숫자 : 5
단계 2 숫자 : 55 , (단계 1 숫자) +-*/ (단계 1 숫자)
단계 3 숫자 : 555 , (단계 1 숫자) +-*/ (단계 2 숫자) , (단계 2 숫자) +-*/ (단계 1 숫자)
단계 4 숫자 : 5555 , (단계 1 숫자) +-*/ (단계 3 숫자) , (단계 3 숫자) +-*/ (단계 1 숫자) , (단계 2 숫자) +-*/ (단계 2 숫자)
단계 5 숫자 : 55555 , (단계 1 숫자) +-*/ (단계 4 숫자) , (단계 2 숫자) +-*/ (단계 3 숫자) , (단계 3 숫자) +-*/ (단계 2 숫자) , (단계 4 숫자) +-*/ (단계 1 숫자)
단계 n 숫자 : '5'*n , (1)(n-1) , (2)(n-2) , ... , (n-1)(1)


문제의 성질에 따라 동적계획법으로 풀어냄으로써
탐색해야하는 범위를 효과적으로 줄일 수 있다
'''

def solution(N, number):
    # 집합 set()을 사용해서 중복 삭제
    # s = [set()] * 8은 각 원소가 같은 주소값을 바라봄
    s = [set() for _ in range(8)]
    
    for i, x in enumerate(s, start=1):
        x.add(N*int('1'*i)) # 각 단계에 연속된 숫자 추가
    
    # 1번 단계에는 값 1개니까 pass
    for i in range(1, len(s)):
        # 각 단계마다 조합할 숫자 구하기 위해 반복문 사용
        for j in range(i):
            for op1 in s[j]: # 0 ~ i-1
                for op2 in s[i - j - 1]: # i-1 ~ 0
                    s[i].add(op1 + op2) # op1, op2 순서 바껴도 결과 동일
                    s[i].add(op1 - op2)
                    s[i].add(op1 * op2) # op1, op2 순서 바껴도 결과 동일
                    if op2 != 0:
                        s[i].add(op1 // op2)
        
        if number in s[i]:
            answer = i+1
            break
    else: # 반복문이 조건문에 걸리지 않고 끝까지 다 진행한 경우
        answer = -1
    
    return answer













